---
title: "singlecellTK"
author: "Shreya Nalluri"
date: "2024-07-02"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
```{r}
library(dplyr)
library(Seurat)
library(patchwork)
library(SeuratData)
library(SeuratWrappers)
library(tidyverse)
#library(Azimuth)
library(ggplot2)
library(sctransform)
#library(leidenAlg)
#library(leiden)
#library(reticulate)
library(biomaRt)
#library(decontX)
library(singleCellTK)
library(EnhancedVolcano)
selectSCTKVirtualEnvironment("sctk-reticulate")
```

###Read in data for singleCellTK
```{r pressure, echo=FALSE}
dropletsce <- importCellRangerV3(cellRangerDirs = "/projectnb/zeldich/GEX_FA_SN_MS/data/cellranger_counts/scRNA-seq",dataType = "raw")
cellsce <- importCellRangerV3(cellRangerDirs = "/projectnb/zeldich/GEX_FA_SN_MS/data/cellranger_counts/scRNA-seq",dataType = "filtered")
sample.vector = colData(cellsce)$sample
```

###Cell QC 

```{r}
# UMAP:
cellsce <- runUMAP(
  inSCE = cellsce,
  useAssay = "counts",
  useAltExp = NULL,
  useReducedDim = NULL,
  sample = NULL,
  reducedDimName = "UMAP",
  logNorm = TRUE,
  nNeighbors = 30,
  nIterations = 200,
  alpha = 1,
  minDist = 0.01,
  spread = 1,
  pca = TRUE,
  initialDims = 25,
  nTop = 2000,
  seed = NULL
)
```

```{r}
#Run cell QC metrics, doublet detection, and decontamination 
set.seed(12345)
cellsce  <- runCellQC(cellsce ,
                           algorithms = c("QCMetrics","scDblFinder","cxds","bcds", "cxds_bcds_hybrid", "doubletFinder", "decontX", "soupX"),
                           mitoRef = "human", mitoIDType = "ensembl", mitoGeneLocation = "rownames")
saveRDS(cellsce,"merge_sctk_sceobj.rds")

#cellsce <- readRDS("merge_sctk_sceobj.rds")

```

##cell QC summary stats
```{r}
cellsce <- sampleSummaryStats(cellsce, sample = sample.vector, simple = FALSE)
getSampleSummaryStatsTable(cellsce, statsName = "qc_table")
```

###Plot doublet detection results 
```{r}
#Plot doublet detection results 
runpercellqc.results <- plotRunPerCellQCResults(inSCE = cellsce, sample = sample.vector, combinePlot = "all", axisSize = 8, axisLabelSize = 9, titleSize = 20, labelSamples=TRUE)

scDblFinder.results <- plotScDblFinderResults(
  inSCE = cellsce, sample = colData(cellsce)$sample, 
  reducedDimName = "UMAP", combinePlot = "sample",
  titleSize = 13,
  axisLabelSize = 13,
  axisSize = 13,
  legendSize = 13,
  legendTitleSize = 13
)

doubletFinderResults <- plotDoubletFinderResults(
  inSCE = cellsce,
  sample = colData(cellsce)$sample, 
  reducedDimName = "UMAP",
  combinePlot = "sample",
  titleSize = 13,
  axisLabelSize = 13,
  axisSize = 13,
  legendSize = 13,
  legendTitleSize = 13
)

cxdsResults <- plotCxdsResults(
  inSCE = cellsce,
  sample = colData(cellsce)$sample, 
  reducedDimName = "UMAP", combinePlot = "sample",
  titleSize = 13,
  axisLabelSize = 13,
  axisSize = 13,
  legendSize = 13,
  legendTitleSize = 13
)

bcdsResults <- plotBcdsResults(
  inSCE = cellsce,
  sample = colData(cellsce)$sample, 
  reducedDimName = "UMAP", combinePlot = "sample",
  titleSize = 13,
  axisLabelSize = 13,
  axisSize = 13,
  legendSize = 13,
  legendTitleSize = 13
)

bcdsCxdsHybridResults <- plotScdsHybridResults(
  inSCE = cellsce, sample = colData(cellsce)$sample, 
  reducedDimName = "UMAP", combinePlot = "sample",
  titleSize = 13,
  axisLabelSize = 13,
  axisSize = 13,
  legendSize = 13,
  legendTitleSize = 13
)

decontxResults <- plotDecontXResults(
  inSCE = cellsce, sample = colData(cellsce)$sample, 
  reducedDimName = "UMAP", combinePlot = "sample",
  titleSize = 8,
  axisLabelSize = 8,
  axisSize = 10,
  legendSize = 5,
  legendTitleSize = 7,
  relWidths = c(0.5, 1, 1),
  sampleRelWidths = c(0.5, 1, 1),
  labelSamples = TRUE,
  labelClusters = FALSE
)

soupxResults <- plotSoupXResults(
  inSCE = cellsce, sample = colData(cellsce)$sample, 
  reducedDimName = "UMAP", combinePlot = "sample",
  titleSize = 8,
  axisLabelSize = 8,
  axisSize = 10,
  legendSize = 5,
  legendTitleSize = 7,
  labelClusters = FALSE
)

```
###Add sctk qc data to seurat object 
```{r}
###Add sctk qc data to seurat object 
sobj <- readRDS("")
# Extract metadata (colData) as a data frame
sce_metadata <- as.data.frame(colData(cellsce))

# Ensure the rownames are cell identifiers
sce_metadata$cell_id <- rownames(sce_metadata)

# Extract cell identifiers from Seurat object
seurat_cell_ids <- colnames(sobj)

# Filter the SCE metadata to include only cells present in the Seurat object
sce_metadata <- sce_metadata[sce_metadata$cell_id %in% seurat_cell_ids, ]

# Reorder SCE metadata to match the order in the Seurat object
sce_metadata <- sce_metadata[match(seurat_cell_ids, sce_metadata$cell_id), ]

# Check the columns to ensure they are properly aligned and ordered
head(sce_metadata)

# Add metadata to the Seurat object
# Exclude the cell_id column if it's present
sobj <- AddMetaData(sobj, metadata = sce_metadata[, -which(names(sce_metadata) == "cell_id")])


# Plotting doublet scores on UMAP
FeaturePlot(sobj, features = c("scDblFinder_doublet_score","scDblFinder_cxds_score","doubletFinder_doublet_score_resolution_1.5","scds_cxds_score","scds_bcds_score","scds_hybrid_score"), reduction = "umap") 

VlnPlot(sobj,features = "decontX_contamination")
#filter out cells with high contamination scores 
sobj <- subset(sobj, decontX_contamination < 0.5)
```
###Ribosomal protein gene analysis 
Originally there was some speculation that some of the clustering was driven by expression of ribosomal protein genes. The following analysis explores this, but we determined this was not the case, and did not continue with any sort of manipulation (regression/filtering) of ribosomal protein genes 

```{r}
###Regress out %ribosomal genes 
sobj[["percent.rpl"]] <- PercentageFeatureSet(sobj, features = RPL.genes)
sobj[["percent.rps"]] <- PercentageFeatureSet(sobj, features = RPS.genes)
sobj[["percent.rb"]] <- PercentageFeatureSet(sobj, features = c(RPL.genes,RPS.genes))

VlnPlot(sobj,features = "percent.rb")
```


```{r}
#regress out %mt and %rb 

#sobj <- SCTransform(sobj, vars.to.regress = c("mitoRatio","percent.rpl","percent.rps"), assay = "decontXcounts")
sobj <- SCTransform(sobj, vars.to.regress = "mitoRatio", assay = "decontXcounts")
#Reduce dimensionality 
sobj <- RunPCA(object = sobj)
#Plot elbow plot to determine appropriate number of dimensions to use in downstream analysis 
ElbowPlot(sobj)
```
```{r}
set.seed(123456)

# Run UMAP
sobj <- RunUMAP(sobj, 
                      dims = 1:17,
                      reduction = "pca")

# Plot UMAP                             
#DimPlot(sobj, group.by = "Differentiation") 

sobj <- FindNeighbors(object = sobj, 
                            dims = 1:17)
sobj <- FindClusters(object = sobj,
                           resolution = c(0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2))

Idents(object = sobj) <- "SCT_snn_res.0.7"
# Plot the UMAP
DimPlot(sobj,
        reduction = "umap",
        label = TRUE,
        label.size = 4)

```

```{r}

FeaturePlot(sobj, features = "percent.rps", reduction = "umap") 
```
```{r}
FeaturePlot(sobj, features = "decontX_contamination")
```
```{r}

# Read the markers CSV file
markers <- read.csv("/projectnb/zeldich/GEX_FA_SN_MS/Zeldich_multiome/cell_markers_layers.csv")

# Convert gene names to uppercase
markers$Gene <- toupper(markers$Gene)

# Replace "PV" with "PVALB"
markers$Gene[markers$Gene == "PV"] <- "PVALB"

# Create a list to store the plots
plot_list <- list()

# Loop through unique cell types
for (cell in unique(markers$Cell.type)) {

  # Filter the markers for the current cell type
  cell_markers <- markers$Gene[markers$Cell.type == cell]

  # Create the DotPlot for the current cell type
  plot <- DotPlot(sobj, features = cell_markers) + 
    RotatedAxis() +
    ggtitle(paste(cell, "Canonical Markers"))
  
  # Store the plot in the list
  plot_list[[cell]] <- plot
  
  # Optionally, display the plot
  print(plot)
}

```


#regressing out combined ribo score 
```{r}
sobj <- SCTransform(sobj, vars.to.regress = c("mitoRatio","percent.rb"), assay = "decontXcounts")
#Reduce dimensionality 
sobj <- RunPCA(object = sobj)
#Plot elbow plot to determine appropriate number of dimensions to use in downstream analysis 
ElbowPlot(sobj)

set.seed(123456)

# Run UMAP
sobj <- RunUMAP(sobj, 
                      dims = 1:17,
                      reduction = "pca")

# Plot UMAP                             
#DimPlot(sobj, group.by = "Differentiation") 

sobj <- FindNeighbors(object = sobj, 
                            dims = 1:17)
sobj <- FindClusters(object = sobj,
                           resolution = c(0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2))

Idents(object = sobj) <- "SCT_snn_res.0.8"
# Plot the UMAP
DimPlot(sobj,
        reduction = "umap",
        label = TRUE,
        label.size = 4)
```
```{r}
FeaturePlot(sobj, features = c("scDblFinder"), reduction = "umap") 
```
###Dotplots for canonical markers 
```{r}

saveRDS(sobj,"rbreg_sctkmeta_seurat.rds")
sobj <- readRDS("rbreg_sctkmeta_seurat.rds")
# Create a list to store the plots
plot_list_2 <- list()

# Loop through unique cell types
for (cell in unique(markers$Cell.type)) {

  # Filter the markers for the current cell type
  cell_markers <- markers$Gene[markers$Cell.type == cell]

  # Create the DotPlot for the current cell type
  plot <- DotPlot(sobj, features = cell_markers) + 
    RotatedAxis() +
    ggtitle(paste(cell, "Canonical Markers"))
  
  # Store the plot in the list
  plot_list_2[[cell]] <- plot
  
  # Optionally, display the plot
  print(plot)
}
```

```{r}
FeaturePlot(sobj, features = c("scDblFinder_doublet_score","scDblFinder_cxds_score","doubletFinder_doublet_score_resolution_1.5","scds_cxds_score","scds_bcds_score","scds_hybrid_score"), reduction = "umap") 
```

```{r}
all_markers <- FindAllMarkers(sobj,only.pos = TRUE) 
#1,19,5,21,18
all_markers_1 <- subset(all_markers, cluster == 1)
DotPlot(sobj,features = all_markers_18$gene[1:5])
all_markers_19 <- subset(all_markers, cluster == 19)
all_markers_5 <- subset(all_markers, cluster == 5)
all_markers_21 <- subset(all_markers, cluster == 21)
all_markers_18 <- subset(all_markers, cluster == 18)
    
all_markers <- subset(all_markers,p_val_adj < 0.05)

write.csv(rb_canon_markers,"rb_canon_markers.csv")

de_18_glial <- FindMarkers(sobj,ident.1 = 18, ident.2 = c(20,9,22,3,4,10,15),only.pos = TRUE)

de_18_glial <- de_18_glial %>%
  mutate("gene" = rownames(de_18_glial))

de_18_glial_canon <- de_18_glial %>%
  inner_join(markers, by = c("gene" = "Gene"))%>%
  subset(p_val_adj < 0.05)

DotPlot(sobj,features = de_18_glial_canon$gene)
```

```{r}
# Fetch data and count cells per cluster by Differentiation
n_cells <- FetchData(sobj, vars = c("Differentiation", 'Chr_Num')) %>%
  mutate(cluster = Idents(sobj)) %>%
  dplyr::count(cluster, Differentiation)

# Stacked bar plot of number of cells per cluster by Differentiation
ggplot(n_cells, aes(x = cluster, y = n, fill = Differentiation)) +
  geom_bar(position = "stack", stat = "identity") +
  #geom_text(aes(label = n), vjust = 1.5, position = position_stack(vjust = 0.5)) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  # Rotate labels by 45 degrees
  xlab("Cluster") + 
  ylab("Number of Cells") + 
  ggtitle("Number of Cells per Cluster by Line")



```
```{r}
#preliminary cluster annotation 
rb_annot <- read.csv("rb_clust_annot.csv")
new.cluster.ids <- rb_annot$I
names(new.cluster.ids) <- levels(sobj)
sobj <- RenameIdents(sobj, new.cluster.ids)
DimPlot(sobj, reduction = "umap", label = TRUE, pt.size = 0.5) #+ NoLegend()

#COL1A2

FeaturePlot(sobj, features = "COL1A2")
DotPlot(sobj, features = "COL1A2")
```

```{r}
FeaturePlot(sobj,"EOMES")
```

```{r}
###Feature plots for ribosomal genes too 

RPS.genes <- grep(pattern = "^RPS", x = rownames(sobj), value = TRUE)
#percent.RPS <- Matrix::colSums(Mgcoculture@raw.data[RPS.genes, ])/Matrix::colSums(Mgcoculture@raw.data)
#Mgcoculture <- AddMetaData(object = Mgcoculture, metadata = percent.RPS, col.name = "percent.RPS")
RPL.genes <- grep(pattern = "^RPL", x = rownames(sobj), value = TRUE)
#percent.RPL <- Matrix::colSums(Mgcoculture@raw.data[RPL.genes, ])/Matrix::colSums(Mgcoculture@raw.data)
#Mgcoculture <- AddMetaData(object = Mgcoculture, metadata = percent.RPL, col.name = "percent.RPL")


FeaturePlot(sobj, features = RPS.genes[11:20], reduction = "umap") 
```
###Filter out Ribosomal Genes completely 

```{r}
norb_sobj <- subset(sobj, features = setdiff(rownames(sobj), c(RPL.genes,RPS.genes)))

norb_sobj <- SCTransform(norb_sobj, vars.to.regress = "mitoRatio", assay = "decontXcounts")
#Reduce dimensionality 
norb_sobj <- RunPCA(object = norb_sobj)
#Plot elbow plot to determine appropriate number of dimensions to use in downstream analysis 
ElbowPlot(norb_sobj)

set.seed(123456)

# Run UMAP
norb_sobj <- RunUMAP(norb_sobj, 
                      dims = 1:17,
                      reduction = "pca")

# Plot UMAP                             
#DimPlot(sobj, group.by = "Differentiation") 

norb_sobj <- FindNeighbors(object = norb_sobj, 
                            dims = 1:17)
norb_sobj <- FindClusters(object = norb_sobj,
                           resolution = c(0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2))

Idents(object = norb_sobj) <- "SCT_snn_res.0.8"
# Plot the UMAP
DimPlot(norb_sobj,
        reduction = "umap",
        label = TRUE,
        label.size = 4)

norb_all_markers <- FindAllMarkers(sobj,only.pos = TRUE)
```
```{r}
FeaturePlot(norb_sobj, features = c("scDblFinder_doublet_score","scDblFinder_cxds_score","doubletFinder_doublet_score_resolution_1.5","scds_cxds_score","scds_bcds_score","scds_hybrid_score"), reduction = "umap") 
```
```{r}
# Fetch data and count cells per cluster by Differentiation
n_cells <- FetchData(sobj, vars = c("Differentiation", 'Chr_Num')) %>%
  mutate(cluster = Idents(sobj)) %>%
  dplyr::count(cluster, Differentiation)

# Stacked bar plot of number of cells per cluster by Differentiation
ggplot(n_cells, aes(x = cluster, y = n, fill = Differentiation)) +
  geom_bar(position = "stack", stat = "identity") +
  #geom_text(aes(label = n), vjust = 1.5, position = position_stack(vjust = 0.5)) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  # Rotate labels by 45 degrees
  xlab("Cluster") + 
  ylab("Number of Cells") + 
  ggtitle("Number of Cells per Cluster by Line")
```
```{r}

FeaturePlot(norb_sobj,features = "decontX_contamination")
```


```{r}
FeaturePlot(norb_sobj,"EOMES")
```

```{r}
FeaturePlot(norb_sobj, features = c("scDblFinder_doublet_score","scDblFinder_cxds_score","doubletFinder_doublet_score_resolution_1.5","scds_cxds_score","scds_bcds_score","scds_hybrid_score"), reduction = "umap") 
```

```{r}
library(ggplot2) # Make sure ggplot2 is loaded as your plots likely use ggplot2 objects
#library(SingleCellExperiment)

# Generate the plots and save them to variables
runpercellqc.results <- plotRunPerCellQCResults(inSCE = cellsce, sample = sample.vector, combinePlot = "all", axisSize = 8, axisLabelSize = 9, titleSize = 20, labelSamples = TRUE)

scDblFinder.results <- plotScDblFinderResults(
  inSCE = cellsce, sample = colData(cellsce)$sample, 
  reducedDimName = "UMAP", combinePlot = "all",
  titleSize = 13,
  axisLabelSize = 13,
  axisSize = 13,
  legendSize = 13,
  legendTitleSize = 13
)

doubletFinderResults <- plotDoubletFinderResults(
  inSCE = cellsce,
  sample = colData(cellsce)$sample, 
  reducedDimName = "UMAP",
  combinePlot = "all",
  titleSize = 13,
  axisLabelSize = 13,
  axisSize = 13,
  legendSize = 13,
  legendTitleSize = 13
)

cxdsResults <- plotCxdsResults(
  inSCE = cellsce,
  sample = colData(cellsce)$sample, 
  reducedDimName = "UMAP", combinePlot = "all",
  titleSize = 13,
  axisLabelSize = 13,
  axisSize = 13,
  legendSize = 13,
  legendTitleSize = 13
)

bcdsResults <- plotBcdsResults(
  inSCE = cellsce,
  sample = colData(cellsce)$sample, 
  reducedDimName = "UMAP", combinePlot = "all",
  titleSize = 13,
  axisLabelSize = 13,
  axisSize = 13,
  legendSize = 13,
  legendTitleSize = 13
)

bcdsCxdsHybridResults <- plotScdsHybridResults(
  inSCE = cellsce, sample = colData(cellsce)$sample, 
  reducedDimName = "UMAP", combinePlot = "all",
  titleSize = 13,
  axisLabelSize = 13,
  axisSize = 13,
  legendSize = 13,
  legendTitleSize = 13
)

decontxResults <- plotDecontXResults(
  inSCE = cellsce, sample = colData(cellsce)$sample, 
  reducedDimName = "UMAP", combinePlot = "all",
  titleSize = 8,
  axisLabelSize = 8,
  axisSize = 10,
  legendSize = 5,
  legendTitleSize = 7,
  relWidths = c(0.5, 1, 1),
  sampleRelWidths = c(0.5, 1, 1),
  labelSamples = TRUE,
  labelClusters = FALSE
)

soupxResults <- plotSoupXResults(
  inSCE = cellsce, sample = colData(cellsce)$sample,
  reducedDimName = "UMAP", combinePlot = "all",
  titleSize = 8,
  axisLabelSize = 8,
  axisSize = 10,
  legendSize = 5,
  legendTitleSize = 7,
  labelClusters = FALSE
)

# Open a PDF device to save the plots
```

###Trying different integration methods using sctk 
Many different integration methods were tested, ultimately we chose to use ComBatSeq, without any additional covariates 
```{r}
old_annot <- readRDS("/projectnb/zeldich/GEX_FA_SN_MS/Zeldich_multiome/res7_cluster_annot_seurat.rds") ##This object does not have sctk qc results 

#Add unintegrated annotations to seurat object 
annot <- read.csv("/projectnb/zeldich/GEX_FA_SN_MS/Zeldich_multiome/cluster_annotations.csv")
new.cluster.ids <- annot$Identity
names(new.cluster.ids) <- levels(old_annot)
old_annot<- RenameIdents(old_annot, new.cluster.ids)

#extract unintegrated annotations 
old_annot$uninteg_annot <- Idents(old_annot)
```

```{r}
integ_seurat <- readRDS("rbreg_sctkmeta_seurat.rds")
#Add unintegrated annotations to seurat object that also has the sctk qc results 
integ_seurat$uninteg_annot <- Idents(old_annot)

integ_seurat <- SCTransform(integ_seurat, vars.to.regress = "mitoRatio", assay = "decontXcounts")

#split integ seurat into separate objects 
seurat_list <- SplitObject(integ_seurat, split.by = "sample")

#convert each object to sce 

# Initialize an empty list to store SCE objects
sce_list <- list()

# Convert each Seurat object to SCE
for (name in names(seurat_list)) {
  seurat_obj <- seurat_list[[name]]
  
  # Convert Seurat object to SingleCellExperiment
  sce_obj <- as.SingleCellExperiment(seurat_obj, assay = "decontXcounts")
  
  # Store the SCE object in the list
  sce_list[[name]] <- sce_obj
}

#combine sceobj into one merged object for batch correction

sce_integ <- combineSCE(sce_list, by.r = NULL, by.c = NULL, combined = TRUE)

saveRDS(sce_integ, "sce_integ_sctk.rds")
```
#Trying Different Integration Methods 

###BBKNN integration 
This crashes every time I try to run it 
```{r}
runBBKNN(
  sce_integ,
  useAssay = "logcounts",
  batch = "Differentiation",
  reducedDimName = "BBKNN",
  nComponents = 50L
)
```


###ComBatSeq
```{r}
sce_integ <- readRDS("sce_integ_sctk.rds")

sce_integ <- runComBatSeq(
  sce_integ,
  useAssay = "counts",
  batch = "Differentiation",
  covariates = "NULL",
  bioCond = NULL,
  useSVA = FALSE,
  assayName = "ComBatSeq",
  shrink = FALSE,
  shrinkDisp = FALSE,
  nGene = NULL
)
```
###FastMNN
```{r}
sce_integ <- runFastMNN(
  sce_integ,
  useAssay = "logcounts",
  useReducedDim = NULL,
  batch = "Differentiation",
  reducedDimName = "fastMNN",
  k = 20,
  propK = NULL,
  ndist = 3,
  minBatchSkip = 0,
  cosNorm = TRUE,
  nComponents = 50,
  weights = NULL,
  BPPARAM = BiocParallel::SerialParam()
)
```

###MNN
```{r}
sce_integ <- runMNNCorrect(
  sce_integ,
  useAssay = "logcounts",
  batch = "Differentiation",
  assayName = "MNN",
  k = 20L,
  propK = NULL,
  sigma = 0.1,
  cosNormIn = TRUE,
  cosNormOut = TRUE,
  varAdj = TRUE,
  BPPARAM = BiocParallel::SerialParam()
)
```


###Limma
```{r}
sce_integ <- runLimmaBC(sce_integ, useAssay = "logcounts", assayName = "LIMMA", batch = "Differentiation")
```

###Scanorama
```{r}
#not working
sce_integ <- runSCANORAMA(
  sce_integ,
  useAssay = "logcounts",
  batch = "Differentiation",
  assayName = "SCANORAMA",
  SIGMA = 15,
  ALPHA = 0.1,
  KNN = 20,
  approx = TRUE
)

###scMerge 
# need to fix 
sce_integ <- runSCMerge(
  sce_integ,
  useAssay = "logcounts",
  batch = "Differentiation",
  assayName = "scMerge",
  hvgExprs = "counts",
  seg = NULL,
  kmeansK = NULL,
  cellType = NULL,
  BPPARAM = BiocParallel::SerialParam()
)

###Seurat Integration

sce_integ <- runSeuratIntegration(
  sce_integ,
  useAssay = "counts",
  "Differentiation",
  newAssayName = "SeuratIntegratedAssay",
  5,
  200,
  30,
  ndims = 10
)

###ZinBWaVE

sce_integ <- runZINBWaVE(
  sce_integ,
useAssay = "counts",
  batch = "Differentiation",
  nHVG = 1000L,
  nComponents = 50L,
  epsilon = 1000,
  nIter = 10L,
  reducedDimName = "zinbwave",
  BPPARAM = BiocParallel::SerialParam()
)

###MNN 
sce_integ <- runMNNCorrect(
  sce_integ,
  useAssay = "logcounts",
  batch = "Differentiation",
  assayName = "MNN",
  k = 20L,
  propK = NULL,
  sigma = 0.1,
  cosNormIn = TRUE,
  cosNormOut = TRUE,
  varAdj = TRUE,
  BPPARAM = BiocParallel::SerialParam()
)

saveRDS(sce_integ, "sce_integ_sctk.rds")
sce_integ <- readRDS("sce_integ_sctk.rds")
```


```{r}
#Add Assays and reduced dimensions from sce object to seurat object 
# Load necessary libraries
library(Seurat)
library(SingleCellExperiment)
library(Matrix)

# Assume `sce_obj` is your SingleCellExperiment object and `seurat_obj` is your Seurat object

seurat_obj <- readRDS("rbreg_sctkmeta_seurat.rds")
# Extract and add assays from SCE to Seurat
#assay_names <- assayNames(sce_integ)
#for (assay_name in assay_names) {
  assay_data <- assay(sce_integ, "ComBatSeq")
  #if (is(assay_data, "sparseMatrix")) {
  seurat_obj[["ComBatSeq"]] <- CreateAssayObject(counts = assay_data)
#   } else {
#     seurat_obj[[assay_name]] <- CreateAssayObject(counts = as(assay_data, "sparseMatrix"))
#   }
# }

# # Extract and add reduced dimensions from SCE to Seurat
# reduced_dim_names <- reducedDimNames(sce_integ)
# for (dim_name in reduced_dim_names) {
#   reduced_dim_data <- reducedDim(sce_integ, dim_name)
#   seurat_obj[[dim_name]] <- CreateDimReducObject(embeddings = reduced_dim_data, key = dim_name)
# }

# # Verify the assays and reduced dimensions have been added
# print(Assays(seurat_obj))
# print(Embeddings(seurat_obj))
# 
# # Identify the assays you want to keep
# assays_to_keep <- setdiff(Assays(seurat_obj), c("counts", "logcounts"))
# 
# # Create a new Seurat object retaining only the desired assays
# seurat_obj <- DietSeurat(seurat_obj, assays = assays_to_keep)
  
seurat_obj_subset <- DietSeurat(
  seurat_obj,
  assays = c("RNA","decontXcounts","SCT","ComBatSeq"),
)

seurat_obj <- seurat_obj_subset
seurat_obj$uninteg_annot <- Idents(old_annot)
saveRDS(seurat_obj,"integ_sctkmeta_seurat.rds")
```



```{r}
FeaturePlot(seurat_obj,reduction = "umap", "EOMES")
```

```{r}
seurat_obj <- readRDS("/projectnb/zeldich/FA_scRNAseq_SN_MS/data/seurat_objects/integ_sctkmeta_seurat.rds")

saveRDS(seurat_obj,"integ_sctkmeta_seurat.rds")
```

#Downstream analysis for integration methods that create a new assay 
```{r}
set.seed(123456)
seurat_obj <- SCTransform(seurat_obj, vars.to.regress = "mitoRatio", assay = "decontXcounts")


seurat_obj <- seurat_obj %>%
  NormalizeData(assay = "ComBatSeq") %>%
  FindVariableFeatures(selection.method = "vst", assay = "ComBatSeq",nfeatures = 2000) %>% 
  ScaleData(assay = "ComBatSeq") 

seurat_obj <- RunPCA(
  seurat_obj,
  assay = "ComBatSeq",reduction.name = "combat_pca"
)

ElbowPlot(seurat_obj, reduction = "combat_pca")


seurat_obj <- RunUMAP(seurat_obj, assay = "ComBatSeq", dims = 1:20, reduction = "combat_pca",reduction.name  = "combat_umap")
DefaultAssay(seurat_obj) <- "ComBatSeq"
DimPlot(seurat_obj, reduction = "combat_umap") 
#SNN analysis for clustering 
seurat_obj <- FindNeighbors(object = seurat_obj,reduction = "combat_pca")
#Cluster determination 
seurat_obj <- FindClusters(object = seurat_obj,resolution =  c(0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2))

DimPlot(seurat_obj, reduction = "combat_umap", split.by = "Differentiation") 
Idents(object = seurat_obj) <- "ComBatSeq_snn_res.0.7"
# Plot the UMAP
DimPlot(seurat_obj,
        reduction = "combat_umap",
        label = TRUE,
        label.size = 4)
```
```{r}
degs_2 <- FindMarkers(seurat_obj,ident.1 = "eu",ident.2="tri", subset.ident = "2")


```

###Dotplots for each cell type
```{r}
markers <- read.csv("/projectnb/zeldich/GEX_FA_SN_MS/Zeldich_multiome/cell_markers_layers.csv")
# Convert gene names to uppercase
markers$Gene <- toupper(markers$Gene)

markers$Gene[markers$Gene == "PV"] <- "PVALB"

plot_list <- list()

# Iterate over each cell type and create a DotPlot
for (cell in unique(markers$Cell.type)) {
    marker_genes <- markers$Gene[markers$Cell.type == cell]
    
    # Create a DotPlot
    plot <- DotPlot(seurat_obj, features = marker_genes) + 
      RotatedAxis() + 
      ggtitle(paste(cell, "Canonical Markers"))
    
    # Add the plot to the list
    plot_list[[cell]] <- plot
    print(plot)
}


combat_canon_markers <- combat_allmarkers %>%
  inner_join(markers, by = c("gene" = "Gene"))%>%
  subset(p_val_adj < 0.05)

write.csv(combat_canon_markers,"ComBatSeq_all_canonmarkers.csv", row.names = FALSE)


```

```{r}
# Fetch data and count cells per cluster by Differentiation
n_cells <- FetchData(seurat_obj, vars = c("Differentiation", 'sample')) %>%
  mutate(cluster = Idents(seurat_obj)) %>%
  dplyr::count(cluster, Differentiation)

# Stacked bar plot of number of cells per cluster by Differentiation
ggplot(n_cells, aes(x = cluster, y = n, fill = Differentiation)) +
  geom_bar(position = "stack", stat = "identity") +
  #geom_text(aes(label = n), vjust = 1.5, position = position_stack(vjust = 0.5)) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  # Rotate labels by 45 degrees
  xlab("Cluster") + 
  ylab("Number of Cells") + 
  ggtitle("Number of Cells per Cluster by Line")

#Plot old annotations on integrated data 
Idents(object = seurat_obj) <- "uninteg_annot"
# Plot the UMAP
DimPlot(seurat_obj,
        reduction = "umap",
        label = TRUE,
        label.size = 4)


DefaultAssay(seurat_obj) <- "ComBatSeq"
#Preliminary Cluster Annotation 
all_markers <- FindAllMarkers(seurat_obj,only.pos = TRUE)
#Read in canonical markers list 
markers <- read.csv("/projectnb/zeldich/GEX_FA_SN_MS/Zeldich_multiome/cell_markers_layers.csv")
# Convert gene names to uppercase
markers$Gene <- toupper(markers$Gene)

cluster13_markers <- all_markers%>%
  subset(cluster == 13)%>%
  head(25)

# Open a PNG device
png("combatseq_cluster13.png", width = 1000, height = 600)

# Generate your plot
DotPlot(seurat_obj,cluster13_markers$gene) + RotatedAxis() 

# Close the device to save the file
dev.off()


markers$Gene[markers$Gene == "PV"] <- "PVALB"

integ_canon_markers <- all_markers %>%
  inner_join(markers, by = c("gene" = "Gene"))%>%
  subset(p_val_adj < 0.05)

write.csv(integ_canon_markers,"ComBatSeq_all_canonmarkers.csv", row.names = FALSE)
```
```{r}

#remove cluster 22 as it is only coming from one line
seurat_obj <- subset(seurat_obj, idents = 22,invert = TRUE)


integ_annotations <- read.csv("combatseq_annot.csv")
new.cluster.ids <- integ_annotations$Identity
names(new.cluster.ids) <- integ_annotations$Cluster
seurat_obj <- RenameIdents(seurat_obj, new.cluster.ids)
seurat_obj$EZ_annot <- Idents(seurat_obj)
DimPlot(seurat_obj, reduction = "umap", label = TRUE, pt.size = 0.5) #+ NoLegend()
```

```{r}
#LGE Genes 
FeaturePlot(seurat_obj, features = c("DLX1","DLX2","ETV1","SP8"),reduction = "combat_umap")
            
FeaturePlot(seurat_obj,features = c("TSHZ1", "ARX","ZFHX3","ESRG"),reduction = "combat_umap")

FeaturePlot(seurat_obj,features = c("MEIS2", "PBX1", "SIX3", "VAX1"),reduction = "combat_umap")
                                     
FeaturePlot(seurat_obj,features = c("MYRF", "EMX1"),reduction = "combat_umap")  

#MYRF and EMX1

DotPlot(seurat_obj,features = c("GSX2","EMX1","NKX2-1"))
DotPlot(seurat_obj,features = c("DLX1","DLX2","ETV1","SP8","TSHZ1", "ARX","ZFHX3","ESRG","MEIS2", "PBX1", "SIX3", "VAX1","MYRF", "EMX1")) + RotatedAxis()

png("combatseq_cluster13.png", width = 1000, height = 600)

# Generate your plot
DotPlot(seurat_obj,cluster13_markers$gene) + RotatedAxis() 

# Close the device to save the file
dev.off()

                                   
```

```{r}
DotPlot(seurat_obj,features = c("SOX6", "DLX1", "DLX2", "ARX","MAFB", "ERBB4", "EPHB3","RUNX1T1","MYT1L", "ETV1", "GBX1", "ZIC1","SMARCD3", "LHX1", "MYT1", "ZFHX4")) + RotatedAxis()

```

#MGE Markers 
```{r}

FeaturePlot(seurat_obj, features = list5,reduction = "combat_umap")

list2 <- c("SOX6", "DLX1", "DLX2", "ARX")
list3 <- c( "MAFB", "ERBB4", "EPHB3","RUNX1T1")
list4 <- c("MYT1L", "ETV1", "GBX1", "ZIC1")
list5 <- c("SMARCD3", "LHX1", "MYT1", "ZFHX4")


```

#Save ExN Plot for easier visualization
```{r}
# Open a PNG device
png("combatseq_ExN.png", width = 800, height = 600)

# Generate your plot
print(plot_list["ExN"])

# Close the device to save the file
dev.off()
```
###Investigating Cluster 13 to help with annotation

###Pathway analysis
```{r}
library(enrichR)
DEenrichRPlot(
  seurat_obj,
  ident.1 = 13,
  ident.2 = c(1:12,14:21),
  balanced = TRUE,
  logfc.threshold = 0.25,
  max.genes = 200,
  assay = "ComBatSeq",
  test.use = "wilcox",
  p.val.cutoff = 0.05,
  enrich.database = "Allen_Brain_Atlas_down"
)
```
###Automatic annotation using sctype 
```{r}
# load libraries and functions
lapply(c("dplyr","Seurat","HGNChelper","openxlsx"), library, character.only = T)
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R"); source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")

# DB file
db_ <- "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx";
tissue <- "Brain" # e.g. Immune system,Pancreas,Liver,Eye,Kidney,Brain,Lung,Adrenal,Heart,Intestine,Muscle,Placenta,Spleen,Stomach,Thymus 

# prepare gene sets
gs_list <- gene_sets_prepare(db_, tissue)


# check Seurat object version (scRNA-seq matrix extracted differently in Seurat v4/v5)
seurat_package_v5 <- isFALSE('counts' %in% names(attributes(seurat_obj[["ComBatSeq"]])));
print(sprintf("Seurat object %s is used", ifelse(seurat_package_v5, "v5", "v4")))

# extract scaled scComBatSeq-seq matrix
scRNAseqData_scaled <- if (seurat_package_v5) as.matrix(seurat_obj[["ComBatSeq"]]$scale.data) else as.matrix(seurat_obj[["ComBatSeq"]]@scale.data)

# run ScType
es.max <- sctype_score(scRNAseqData = scRNAseqData_scaled, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)

# NOTE: scRNAseqData parameter should correspond to your input scRNA-seq matrix. For raw (unscaled) count matrix set scaled = FALSE
# When using Seurat, we use "RNA" slot with 'scale.data' by default. Please change "RNA" to "SCT" for sctransform-normalized data,
# or to "integrated" for joint dataset analysis. To apply sctype with unscaled data, use e.g. seurat_obj[["RNA"]]$counts or seurat_obj[["RNA"]]@counts, with scaled set to FALSE.

# merge by cluster
cL_resutls <- do.call("rbind", lapply(unique(seurat_obj@meta.data$seurat_clusters), function(cl){
    es.max.cl = sort(rowSums(es.max[ ,rownames(seurat_obj@meta.data[seurat_obj@meta.data$seurat_clusters==cl, ])]), decreasing = !0)
    head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(seurat_obj@meta.data$seurat_clusters==cl)), 10)
}))
sctype_scores <- cL_resutls %>% group_by(cluster) %>% top_n(n = 1, wt = scores)  

# set low-confident (low ScType score) clusters to "unknown"
sctype_scores$type[as.numeric(as.character(sctype_scores$scores)) < sctype_scores$ncells/4] <- "Unknown"
print(sctype_scores[,1:3])
```

###DEGS 
```{r}
#Will perform at the single cell level and pseudobulk level and compare 

#single cell deg 
seurat_obj$celltype.geno <- paste(seurat_obj$EZ_annot, seurat_obj$Chr_Num, sep = "_")
Idents(seurat_obj) <- "celltype.geno"
ipc1.de <- FindMarkers(seurat_obj, ident.1 = "IPC1_tri", ident.2 = "IPC1_eu", test.use = "MAST", verbose = FALSE)
head(ipc1.de, n = 10)

#pseudobulk deg 

# pseudobulk the counts based on donor-condition-celltype
pseudo_seurat_obj<- AggregateExpression(seurat_obj, assays = "ComBatSeq", return.seurat = T, group.by = c("EZ_annot","Chr_Num"))
Idents(pseudo_seurat_obj) <- "EZ_annot"
# each 'cell' is a donor-condition-celltype pseudobulk profile
pseudo_seurat_obj$celltype.geno <- paste(pseudo_seurat_obj$EZ_annot, pseudo_seurat_obj$Chr_Num, sep = "_")
Cells(pseudo_seurat_obj)
Idents(pseudo_seurat_obj) <- "celltype.geno"
bulk.exn1.de <- FindMarkers(object = pseudo_seurat_obj, 
                         ident.1 = "IPC1_tri", 
                         ident.2 = "IPC1_eu",
                         test.use = "MAST")
head(bulk.ipc1.de , n = 15)

```

```{r}
cells_group_1 <- WhichCells(pseudo_seurat_obj, idents = "ExN1 (upper layer)_eu")
cells_group_2 <- WhichCells(pseudo_seurat_obj, idents = "ExN1 (upper layer)_tri")

length(cells_group_1)  # Number of cells in group 1
length(cells_group_2)  # Number of cells in group 2

```

```{r}
# Extract unique identities
idents <- unique(Idents(seurat_obj))

# Initialize a list to store results
de_results <- list()

# Nested loop to iterate through each pair of identities
# Loop through the idents vector in steps of 2
for (i in seq(2, length(idents), by = 2)) {
  ident1 <- idents[i]
  ident2 <- idents[i - 1]
  
  # Perform differential expression analysis
  de_result <- FindMarkers(
    object = seurat_obj,
    ident.1 = ident1,
    ident.2 = ident2,
    test.use = "MAST" # or any other method
  )
    
    # Store results in a list with a descriptive name
    comparison_name <- paste(ident1, "vs", ident2, sep = "_")
    de_results[[comparison_name]] <- de_result
  }


# The de_results list now contains DE results for every pair of idents

#plot DEG results as volcano plots 
  EnhancedVolcano(res,
    lab = rownames(res),
    x = 'log2FoldChange',
    y = 'pvalue')
```
```{r}
# Extract unique identities
# Extract unique identities and convert to character
idents <- unique(as.character(Idents(seurat_obj)))

# Sort the character vector alphabetically
idents <- sort(idents)

# Initialize a list to store results
de_results <- list()

# Nested loop to iterate through each pair of identities
# Loop through the idents vector in steps of 2
for (i in seq(2, length(idents), by = 2)) {
  ident1 <- idents[i]
  ident2 <- idents[i - 1]
  
  # Perform differential expression analysis
  de_result <- FindMarkers(
    object = seurat_obj,
    ident.1 = ident1,
    ident.2 = ident2,
    test.use = "MAST" # or any other method
  )
    
  # Store results in a list with a descriptive name
  comparison_name <- paste(ident1, "vs", ident2, sep = "_")
  de_results[[comparison_name]] <- de_result

  # Generate a volcano plot for this comparison
  EnhancedVolcano(
    de_result,
    lab = rownames(de_result),
    x = 'avg_log2FC',        # Column for log2 fold change
    y = 'p_val_adj',     # Column for adjusted p-value
    title = comparison_name,
    xlab = "Log2 Fold Change",
    ylab = "-Log10 Adjusted P-value",
    pCutoff = 0.05#,      # Adjust the cutoff as needed
    #FCcutoff = 1.5       # Adjust the fold change cutoff as needed
  )

  # Optionally, save the plot to a file
  ggsave(
    filename = paste0(comparison_name, "_volcano.png"),
    plot = last_plot(),
    width = 8,
    height = 6
  )
}

#save results of each comparison as a csv file

for (name in names(de_results)) {
  # Create a filename based on the name of the list element
  file_name <- paste0(name, ".csv")
  
  # Save the data frame as a CSV file
  write.csv(de_results[[name]], file = file_name, row.names = TRUE)
}

# The de_results list now contains DE results for every pair of idents

```

##Explore OL/OPC clusters 
#Combine early and late stage OPC clusters (21 & 9) and perform DEG analysis 
```{r}
#Merge cluster 9 and 21 
seurat_obj <- RenameIdents(object = seurat_obj, `OPC-early stage` = "OPC")
seurat_obj <- RenameIdents(object = seurat_obj, `OPC-late stage ` = "OPC")

seurat_obj$celltype.geno2 <- paste(Idents(seurat_obj), seurat_obj$Chr_Num, sep = "_")
Idents(seurat_obj) <- "celltype.geno2"
unique(Idents(seurat_obj))
opc_merge_de <- FindMarkers(seurat_obj, ident.1 = "OPC_tri", ident.2 = "OPC_eu", test.use = "MAST", verbose = FALSE)
head(opc_merge_de, n = 10)

#plot merged opc de results 

 EnhancedVolcano(
    opc_merge_de,
    lab = rownames(opc_merge_de),
    x = 'avg_log2FC',        # Column for log2 fold change
    y = 'p_val_adj',     # Column for adjusted p-value
    title = "OPC early & late stage (21+9) tri v eu",
    xlab = "Log2 Fold Change",
    ylab = "-Log10 Adjusted P-value",
    pCutoff = 0.05#,      # Adjust the cutoff as needed
    #FCcutoff = 1.5       # Adjust the fold change cutoff as needed
  )

  # Optionally, save the plot to a file
  ggsave(
    filename =  "opcmergede_volcano.png",
    plot = last_plot(),
    width = 8,
    height = 6
  )
```

###Recluster OL/OPC clusters 
```{r}
#Recluster/subcluster early stage OPCs 

#Recluster/subcluster late stage OPCs 

#Recluster early + late stage OPCs together 
OPC_seurat <- subset(seurat_obj, idents = "OPC")

set.seed(123456)

OPC_seurat <- OPC_seurat %>%
  NormalizeData(assay = "ComBatSeq") %>%
  FindVariableFeatures(selection.method = "vst", assay = "ComBatSeq",nfeatures = 2000) %>% 
  ScaleData(assay = "ComBatSeq") 

OPC_seurat <- RunPCA(
  OPC_seurat,
  assay = "ComBatSeq",reduction.name = "combat_pca"
)

ElbowPlot(OPC_seurat, reduction = "combat_pca")


OPC_seurat <- RunUMAP(OPC_seurat, assay = "ComBatSeq", dims = 1:20, reduction = "combat_pca",reduction.name  = "combat_umap")
DefaultAssay(OPC_seurat) <- "ComBatSeq"
DimPlot(OPC_seurat, reduction = "combat_umap") 
#SNN analysis for clustering 
OPC_seurat <- FindNeighbors(object = OPC_seurat,reduction = "combat_pca")
#Cluster determination 
OPC_seurat <- FindClusters(object = OPC_seurat,resolution =  c(0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2))

DimPlot(OPC_seurat, reduction = "combat_umap", split.by = "sample") 
Idents(object = OPC_seurat) <- "ComBatSeq_snn_res.0.2"
# Plot the UMAP
DimPlot(OPC_seurat,
        reduction = "combat_umap",
        label = TRUE,
        label.size = 4)

#Investigate Cluster identities and compositions to see if there are any genotype specific clusters 
```

###Recluster cluster 19 glial progenitors 
```{r}

```

##Explore InN clusters 
#combine InN clusters and perform DEG analysis 
```{r}

```

###Recluster InN clusters 
```{r}
#Recluster InN1 and InN2 together 
```

###GO Enrichment with Enrichr/David OL/OPC and InN clusters 

```{r}

```

###Pseudotime analysis using monocle3
```{r}

```






###Try combatseq with covariates 
```{r}
#subset annotations to only include excitatory neuron annotations since those are what we are most confident about (These are the annotations on the combatseq corrected data, but with only batch = differentiation parameter; no covariates) For this, I will use the OL_subclus column 

#we are not going along with this method as it did not significantly improve our clustering 

annots <- unique(seurat_obj$OL_subclus)
#select all ExN clusters 
exn_annots <- annots[grepl("ExN", annots)]
#remove questionable/potentially transitioning progenitors that we labeled as ExN 
exn_annots <- exn_annots[exn_annots != "ExN"]
#remove RELN+ cluster 
exn_annots <-exn_annots[exn_annots != "RELN+ ExN"]

seurat_obj[["ExN_annot"]] <- seurat_obj$OL_subclus[seurat_obj$OL_subclus %in% exn_annots]

#Add to sce 
sce_integ$ExN_annot <- seurat_obj$ExN_annot

#Runcombatseq with covariates 
sce_integ <- runComBatSeq(
  sce_integ,
  useAssay = "counts",
  batch = "Differentiation",
  covariates = "uninteg_annot",
  bioCond = NULL,
  useSVA = FALSE,
  assayName = "ComBatSeq_cov",
  shrink = FALSE,
  shrinkDisp = FALSE,
  nGene = NULL
)

#Add ComBAtSeq_cov assay to seurat object 
assay_data <- assay(sce_integ, "ComBatSeq_cov")
seurat_obj[["ComBatSeq_cov"]] <- CreateAssayObject(counts = assay_data)




seurat_obj <- seurat_obj %>%
  NormalizeData(assay = "ComBatSeq_cov") %>%
  FindVariableFeatures(selection.method = "vst", assay = "ComBatSeq_cov",nfeatures = 2000) %>% 
  ScaleData(assay = "ComBatSeq_cov") 

seurat_obj <- RunPCA(
  seurat_obj,
  assay = "ComBatSeq_cov",reduction.name = "combat_cov_pca"
)

ElbowPlot(seurat_obj, reduction = "combat_cov_pca")


seurat_obj <- RunUMAP(seurat_obj, assay = "ComBatSeq_cov", dims = 1:20, reduction = "combat_cov_pca",reduction.name  = "combat_cov_umap")
DefaultAssay(seurat_obj) <- "ComBatSeq_cov"
DimPlot(seurat_obj, reduction = "combat_cov_umap") 
#SNN analysis for clustering 
seurat_obj <- FindNeighbors(object = seurat_obj,reduction = "combat_cov_pca")
#Cluster determination 
seurat_obj <- FindClusters(object = seurat_obj,resolution =  c(0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2))

DimPlot(seurat_obj, reduction = "combat_cov_umap", split.by = "Differentiation") 
Idents(object = seurat_obj) <- "ComBatSeq_cov_snn_res.0.8"
# Plot the UMAP
DimPlot(seurat_obj,
        reduction = "combat_cov_umap",
        label = TRUE,
        label.size = 4)


combatcov_allmarkers <- FindAllMarkers(seurat_obj,only.pos = TRUE)

markers <- read.csv("/projectnb/zeldich/GEX_FA_SN_MS/Zeldich_multiome/cell_markers_layers.csv")
# Convert gene names to uppercase
markers$Gene <- toupper(markers$Gene)

markers$Gene[markers$Gene == "PV"] <- "PVALB"

plot_list <- list()

# Iterate over each cell type and create a DotPlot
for (cell in unique(markers$Cell.type)) {
    marker_genes <- markers$Gene[markers$Cell.type == cell]
    
    # Create a DotPlot
    plot <- DotPlot(seurat_obj, features = marker_genes) + 
      RotatedAxis() + 
      ggtitle(paste(cell, "Canonical Markers"))
    
    # Add the plot to the list
    plot_list[[cell]] <- plot
    print(plot)
}
  

combatcov_canon_markers <- combatcov_allmarkers %>%
  inner_join(markers, by = c("gene" = "Gene"))%>%
  subset(p_val_adj < 0.05)

write.csv(combatcov_canon_markers,"combatcov_all_canonmarkers.csv", row.names = FALSE)


```